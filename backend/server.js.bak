import express from "express";
import fetch from "node-fetch";
import dotenv from "dotenv";
import bodyParser from "body-parser";
import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import cors from "cors";
import rateLimit from "express-rate-limit";
import helmet from "helmet";
import compression from "compression";

dotenv.config();

const app = express();
app.set('trust proxy', 1);

// Middleware
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'", "'unsafe-inline'"],
      frameAncestors: ["https://*.myshopify.com", "https://admin.shopify.com"]
    }
  }
}));
app.use(compression());
app.use(cors());
app.use(bodyParser.json({ limit: '10mb' }));

// Custom CSP middleware
app.use((req, res, next) => {
  res.setHeader(
    'Content-Security-Policy',
    "default-src 'self'; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline'; frame-ancestors https://*.myshopify.com https://admin.shopify.com;"
  );
  next();
});

const {
  SHOPIFY_API_KEY,
  SHOPIFY_API_SECRET,
  SCOPES = "read_products,read_orders,write_products,read_inventory,read_customers",
  HOST,
  PORT = 3000,
  NODE_ENV = 'development'
} = process.env;

if (!SHOPIFY_API_KEY || !SHOPIFY_API_SECRET || !HOST) {
  console.error("‚ùå Missing environment variables");
  process.exit(1);
}

// Enhanced Rate limiting - Shopify App Optimized
const createAccountLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 1000, // Increased limit for Shopify app usage
  message: {
    error: "Too many requests, please try again after 15 minutes",
    retryAfter: 900
  },
  standardHeaders: true,
  legacyHeaders: false,
  keyGenerator: (req) => {
    // Use shop name as key if available, otherwise fall back to IP
    return req.query.shop || req.ip;
  },
  skip: (req) => {
    // Skip rate limiting for webhooks and important endpoints
    if (req.path.includes('/webhooks/')) return true;
    if (req.path === '/health') return true;
    return false;
  },
  handler: (req, res) => {
    const key = req.query.shop || req.ip;
    console.log(`üö® Rate limit exceeded for: ${key}`);
    res.status(429).json({
      error: "Too many requests, please try again later",
      details: `Rate limit exceeded for ${key}`,
      retryAfter: 900,
      tips: [
        "Reduce the frequency of manual refreshes",
        "Use the auto-refresh feature instead",
        "Contact support if this persists"
      ]
    });
  }
});

// Apply to API routes only
app.use('/api/', createAccountLimiter);

// Request logging middleware
app.use((req, res, next) => {
  const start = Date.now();
  res.on('finish', () => {
    const duration = Date.now() - start;
    console.log(`${req.method} ${req.originalUrl} ${res.statusCode} ${duration}ms`);
  });
  next();
});

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// File paths
const TOKENS_FILE = path.join(__dirname, "tokens.json");
const INVENTORY_FILE = path.join(__dirname, "inventory.json");
const ORDERSTATUS_FILE = path.join(__dirname, "orderStatus.json");
const PURCHASE_ORDERS_FILE = path.join(__dirname, "purchaseOrders.json");

// Helper functions
const readJSON = (file) => {
  try {
    if (fs.existsSync(file)) {
      const data = fs.readFileSync(file, "utf8");
      return JSON.parse(data);
    }
    // Return appropriate default based on file type
    if (file === PURCHASE_ORDERS_FILE) {
      return []; // Return empty array for purchase orders
    }
    return {};
  } catch (error) {
    console.error(`‚ùå Error reading ${file}:`, error);
    // Return appropriate default based on file type
    if (file === PURCHASE_ORDERS_FILE) {
      return []; // Return empty array for purchase orders
    }
    return {};
  }
};

const saveJSON = (file, data) => {
  try {
    // Ensure directory exists
    const dir = path.dirname(file);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    fs.writeFileSync(file, JSON.stringify(data, null, 2), "utf8");
    console.log(`‚úÖ Successfully saved ${file}`);
    return true;
  } catch (error) {
    console.error(`‚ùå Error saving ${file}:`, error);
    return false;
  }
};

// Generate unique purchase order ID
const generatePurchaseOrderId = () => {
  return `PO-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`.toUpperCase();
};

// Enhanced GraphQL function with detailed logging
async function graphql(shop, token, query, vars = {}, retries = 3) {
  for (let i = 0; i < retries; i++) {
    try {
      console.log(`üîç GraphQL Attempt ${i + 1} for ${shop}`);
      
      const response = await fetch(`https://${shop}/admin/api/2024-01/graphql.json`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-Shopify-Access-Token": token,
        },
        body: JSON.stringify({ query, variables: vars }),
      });

      console.log(`üì° Response status: ${response.status}`);
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error(`‚ùå HTTP Error: ${response.status}`, errorText);
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const data = await response.json();
      
      if (data.errors) {
        console.error('‚ùå GraphQL Errors:', JSON.stringify(data.errors, null, 2));
        throw new Error(`GraphQL errors: ${JSON.stringify(data.errors)}`);
      }
      
      console.log(`‚úÖ GraphQL Success`);
      return data;
    } catch (error) {
      console.error(`‚ùå GraphQL attempt ${i + 1} failed:`, error.message);
      if (i === retries - 1) throw error;
      await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
    }
  }
}

// Purchase Order Creation Function
async function createPurchaseOrder(orderId, shop, items) {
  try {
    console.log(`üìã Creating purchase order for order: ${orderId}`);
    
    const tokens = readJSON(TOKENS_FILE);
    const token = tokens[shop]?.access_token;
    
    if (!token) {
      throw new Error('No access token available for shop');
    }

    let purchaseOrders = readJSON(PURCHASE_ORDERS_FILE);
    
    // Ensure purchaseOrders is an array
    if (!Array.isArray(purchaseOrders)) {
      purchaseOrders = [];
    }

    // Get order details for the PO
    const orderQuery = `
      query ($id: ID!) {
        order(id: $id) {
          id
          name
          lineItems(first: 10) {
            edges {
              node {
                title
                quantity
                variant {
                  sku
                  title
                }
              }
            }
          }
        }
      }
    `;

    let orderName = `Order ${orderId}`;
    try {
      const orderData = await graphql(shop, token, orderQuery, { id: orderId });
      if (orderData.data?.order) {
        orderName = orderData.data.order.name;
      }
    } catch (error) {
      console.log('‚ö†Ô∏è Could not fetch order details, using fallback name');
    }

    const purchaseOrder = {
      id: generatePurchaseOrderId(),
      originalOrderId: orderId,
      originalOrderName: orderName,
      items: items,
      createdAt: new Date().toISOString(),
      status: 'ordered', // Default status when created
      notes: `Created for order ${orderName} due to out of stock items.`,
      shop: shop
    };

    purchaseOrders.push(purchaseOrder);
    
    const saveSuccess = saveJSON(PURCHASE_ORDERS_FILE, purchaseOrders);
    if (!saveSuccess) {
      throw new Error('Failed to save purchase order to file');
    }
    
    console.log(`‚úÖ Created purchase order ${purchaseOrder.id} with ${items.length} items`);
    return purchaseOrder;
  } catch (error) {
    console.error('‚ùå Error creating purchase order:', error);
    throw error;
  }
}

// OAuth Routes
app.get("/auth", (req, res) => {
  const { shop } = req.query;
  if (!shop) return res.status(400).json({ error: "Missing shop parameter" });

  const redirectUri = `${HOST}/auth/callback`;
  const installUrl = `https://${shop}/admin/oauth/authorize?client_id=${SHOPIFY_API_KEY}&scope=${SCOPES}&redirect_uri=${encodeURIComponent(redirectUri)}`;
  
  console.log(`üîê Starting OAuth for shop: ${shop}`);
  console.log(`üîë Scopes being requested: ${SCOPES}`);
  
  res.redirect(installUrl);
});

app.get("/auth/callback", async (req, res) => {
  try {
    const { shop, code, host } = req.query;
    
    if (!shop || !code) {
      return res.status(400).json({ error: "Missing shop or code parameter" });
    }

    console.log(`üîÑ OAuth callback for shop: ${shop}`);

    const tokenUrl = `https://${shop}/admin/oauth/access_token`;
    const resp = await fetch(tokenUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        client_id: SHOPIFY_API_KEY,
        client_secret: SHOPIFY_API_SECRET,
        code,
      }),
    });

    if (!resp.ok) {
      const errorText = await resp.text();
      console.error(`‚ùå OAuth token exchange failed: ${resp.status}`, errorText);
      throw new Error(`HTTP error! status: ${resp.status}`);
    }
    
    const data = await resp.json();
    const tokens = readJSON(TOKENS_FILE);
    tokens[shop] = {
      access_token: data.access_token,
      installed_at: new Date().toISOString(),
      scopes: data.scope || SCOPES
    };
    
    saveJSON(TOKENS_FILE, tokens);
    
    console.log(`‚úÖ App installed successfully for ${shop}`);
    console.log(`üìã Granted scopes: ${data.scope || SCOPES}`);
    
    const redirectUrl = host 
      ? `https://${shop}/admin/apps/${SHOPIFY_API_KEY}`
      : `${HOST}/?shop=${shop}`;
    
    res.redirect(redirectUrl);
  } catch (error) {
    console.error("‚ùå OAuth error:", error);
    res.status(500).json({ error: "Authentication failed" });
  }
});

// Fixed Orders API without customer field
app.get("/api/orders", async (req, res) => {
  try {
    const { shop } = req.query;
    
    if (!shop) {
      return res.status(400).json({ error: "Missing shop parameter" });
    }

    const tokens = readJSON(TOKENS_FILE);
    const token = tokens[shop]?.access_token;
    
    if (!token) {
      return res.status(403).json({ error: "App not installed" });
    }

    console.log(`üìã Fetching orders for: ${shop}`);
    console.log(`üîë Token exists: ${!!token}`);
    console.log(`üìã Available scopes: ${tokens[shop]?.scopes || 'unknown'}`);

    // Simplified orders query without customer field
    const q = `
      query {
        orders(first: 50, sortKey: CREATED_AT, reverse: true) {
          edges {
            node {
              id
              name
              email
              createdAt
              displayFinancialStatus
              displayFulfillmentStatus
              totalPriceSet {
                shopMoney {
                  amount
                  currencyCode
                }
              }
              lineItems(first: 5) {
                edges {
                  node {
                    title
                    quantity
                    variant {
                      sku
                      title
                    }
                  }
                }
              }
            }
          }
        }
      }
    `;

    const json = await graphql(shop, token, q);
    
    console.log('üìä Raw GraphQL response structure:', {
      hasData: !!json.data,
      hasOrders: !!json.data?.orders,
      orderCount: json.data?.orders?.edges?.length || 0
    });
    
    const orderCount = json.data?.orders?.edges?.length || 0;
    console.log(`‚úÖ Fetched ${orderCount} orders for ${shop}`);
    
    if (orderCount === 0) {
      console.log('‚ÑπÔ∏è No orders found - this could be normal for a new store');
    } else {
      // Log sample order data for debugging
      const sampleOrder = json.data.orders.edges[0].node;
      console.log('üìù Sample order:', {
        id: sampleOrder.id,
        name: sampleOrder.name,
        financialStatus: sampleOrder.displayFinancialStatus,
        fulfillmentStatus: sampleOrder.displayFulfillmentStatus,
        total: sampleOrder.totalPriceSet?.shopMoney?.amount,
        lineItems: sampleOrder.lineItems?.edges?.length || 0
      });
    }
    
    res.json(json);
  } catch (error) {
    console.error("‚ùå Orders API error:", error);
    res.status(500).json({ 
      error: "Failed to fetch orders", 
      details: error.message,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
});

// Products API - Updated to remove shop quantity since we use initial inventory as actual inventory
app.get("/api/products", async (req, res) => {
  try {
    const { shop } = req.query;
    const tokens = readJSON(TOKENS_FILE);
    const token = tokens[shop]?.access_token;
    
    if (!token) return res.status(403).json({ error: "App not installed" });

    console.log(`üì¶ Fetching products for: ${shop}`);

    const q = `
      query {
        products(first: 50) {
          edges {
            node {
              id
              title
              handle
              description
              featuredImage {
                url
              }
              variants(first: 5) {
                edges {
                  node {
                    id
                    sku
                    title
                    price
                    inventoryItem {
                      tracked
                    }
                  }
                }
              }
            }
          }
        }
      }
    `;

    const json = await graphql(shop, token, q);
    const productCount = json.data?.products?.edges?.length || 0;
    console.log(`‚úÖ Fetched ${productCount} products`);
    
    res.json(json);
  } catch (error) {
    console.error("‚ùå Products API error:", error);
    res.status(500).json({ error: "Failed to fetch products" });
  }
});

// Order Status Management with Purchase Order Creation
app.post("/api/order-status", async (req, res) => {
  try {
    const { orderId, status, notes, shop, purchaseOrderItems } = req.body;
    
    console.log(`üîÑ Order status update request:`, {
      orderId,
      status,
      shop,
      hasNotes: !!notes,
      hasPurchaseOrderItems: !!purchaseOrderItems
    });
    
    if (!orderId || !status) {
      return res.status(400).json({ 
        success: false, 
        error: "Missing orderId or status" 
      });
    }

    if (!shop) {
      return res.status(400).json({ 
        success: false, 
        error: "Missing shop parameter" 
      });
    }

    // Verify the app is installed for this shop
    const tokens = readJSON(TOKENS_FILE);
    const token = tokens[shop]?.access_token;
    
    if (!token) {
      return res.status(403).json({ 
        success: false, 
        error: "App not installed for this shop" 
      });
    }

    const data = readJSON(ORDERSTATUS_FILE);
    const timestamp = new Date().toISOString();
    
    // Store the full status object
    const previousStatus = data[orderId]?.status || 'fresh';
    data[orderId] = {
      status: status,
      notes: notes || '',
      updatedAt: timestamp,
      shop: shop,
      history: [
        ...(data[orderId]?.history || []),
        { 
          from: previousStatus, 
          to: status, 
          timestamp, 
          notes: notes || '' 
        }
      ]
    };

    const saveSuccess = saveJSON(ORDERSTATUS_FILE, data);
    if (!saveSuccess) {
      throw new Error('Failed to save order status to file');
    }
    
    console.log(`‚úÖ Updated order ${orderId} status from ${previousStatus} to: ${status}`);

    let purchaseOrder = null;
    
    // CREATE PURCHASE ORDER WHEN STATUS IS OUT_OF_STOCK AND ITEMS ARE PROVIDED
    if (status === 'out_of_stock' && purchaseOrderItems && Array.isArray(purchaseOrderItems) && purchaseOrderItems.length > 0) {
      try {
        console.log(`üìã Creating purchase order for out_of_stock order ${orderId} with ${purchaseOrderItems.length} items`);
        
        purchaseOrder = await createPurchaseOrder(orderId, shop, purchaseOrderItems);
        
        if (purchaseOrder) {
          console.log(`‚úÖ Purchase order created:`, purchaseOrder.id);
        }
      } catch (poError) {
        console.error('‚ùå Purchase order creation failed:', poError);
        // Don't fail the entire request if purchase order creation fails
      }
    }

    const responseData = { 
      success: true, 
      data: data[orderId],
      purchaseOrderCreated: !!purchaseOrder,
      purchaseOrder: purchaseOrder
    };
    
    res.json(responseData);
    
  } catch (error) {
    console.error("‚ùå Order status update error:", error);
    
    const errorResponse = { 
      success: false, 
      error: "Failed to update order status",
      details: error.message
    };
    
    res.status(500).json(errorResponse);
  }
});

// Order Status GET endpoint
app.get("/api/order-status", (req, res) => {
  try {
    const status = readJSON(ORDERSTATUS_FILE);
    res.json(status);
  } catch (error) {
    console.error("‚ùå Order status read error:", error);
    res.status(500).json({ error: "Failed to read order status" });
  }
});

// Get orders by status
app.get("/api/orders-by-status", (req, res) => {
  try {
    const { status, shop } = req.query;
    
    if (!status) {
      return res.status(400).json({ error: "Missing status parameter" });
    }

    const orderStatusData = readJSON(ORDERSTATUS_FILE);
    
    // Filter orders by status
    const filteredOrders = Object.entries(orderStatusData)
      .filter(([orderId, orderData]) => orderData.status === status)
      .map(([orderId, orderData]) => ({
        id: orderId,
        ...orderData
      }));

    console.log(`üìã Found ${filteredOrders.length} orders with status: ${status}`);
    
    res.json({
      status: status,
      count: filteredOrders.length,
      orders: filteredOrders
    });
  } catch (error) {
    console.error("‚ùå Orders by status error:", error);
    res.status(500).json({ error: "Failed to fetch orders by status" });
  }
});

// Purchase Orders API
app.get("/api/purchase-orders", (req, res) => {
  try {
    let purchaseOrders = readJSON(PURCHASE_ORDERS_FILE);
    
    // Ensure we always return an array
    let ordersArray = [];
    
    if (Array.isArray(purchaseOrders)) {
      ordersArray = purchaseOrders;
    } else if (typeof purchaseOrders === 'object' && purchaseOrders !== null) {
      ordersArray = Object.values(purchaseOrders);
    }
    
    // Sort by creation date (newest first)
    ordersArray.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
    
    console.log(`üìã Serving ${ordersArray.length} purchase orders`);
    res.json(ordersArray);
  } catch (error) {
    console.error("‚ùå Purchase orders read error:", error);
    // Return empty array on error
    res.json([]);
  }
});

// Create Purchase Order Endpoint
app.post("/api/purchase-orders/create", async (req, res) => {
  try {
    const { orderId, shop, items } = req.body;
    
    console.log(`üîÑ Purchase order creation request:`, {
      orderId,
      shop,
      itemCount: items?.length || 0
    });
    
    if (!orderId || !shop || !items || !Array.isArray(items)) {
      return res.status(400).json({ 
        success: false, 
        error: "Missing orderId, shop, or items array" 
      });
    }

    // Verify the app is installed for this shop
    const tokens = readJSON(TOKENS_FILE);
    const token = tokens[shop]?.access_token;
    
    if (!token) {
      return res.status(403).json({ 
        success: false, 
        error: "App not installed for this shop" 
      });
    }

    const purchaseOrder = await createPurchaseOrder(orderId, shop, items);
    
    res.json({
      success: true,
      purchaseOrder,
      message: `Purchase order ${purchaseOrder.id} created successfully`
    });
    
  } catch (error) {
    console.error("‚ùå Purchase order creation error:", error);
    res.status(500).json({ 
      success: false,
      error: "Failed to create purchase order",
      details: error.message
    });
  }
});

// Update Purchase Order Status
app.post("/api/purchase-orders/:id/status", (req, res) => {
  try {
    const { id } = req.params;
    const { status } = req.body;
    
    console.log(`üîÑ Purchase Order Status Update:`, {
      purchaseOrderId: id,
      newStatus: status
    });
    
    if (!status) {
      return res.status(400).json({ 
        success: false,
        error: "Missing status" 
      });
    }

    let purchaseOrders = readJSON(PURCHASE_ORDERS_FILE);
    let ordersArray = [];
    
    // Handle different data structures
    if (Array.isArray(purchaseOrders)) {
      ordersArray = purchaseOrders;
    } else if (typeof purchaseOrders === 'object' && purchaseOrders !== null) {
      ordersArray = Object.values(purchaseOrders);
    } else {
      ordersArray = [];
    }
    
    const purchaseOrderIndex = ordersArray.findIndex(po => po.id === id);
    
    if (purchaseOrderIndex === -1) {
      return res.status(404).json({ 
        success: false,
        error: "Purchase order not found" 
      });
    }

    // Update the purchase order status
    const previousStatus = ordersArray[purchaseOrderIndex].status;
    ordersArray[purchaseOrderIndex].status = status;
    ordersArray[purchaseOrderIndex].updatedAt = new Date().toISOString();
    
    const saveSuccess = saveJSON(PURCHASE_ORDERS_FILE, ordersArray);
    if (!saveSuccess) {
      throw new Error('Failed to save purchase order status to file');
    }
    
    console.log(`‚úÖ Updated purchase order ${id} status from ${previousStatus} to ${status}`);
    
    res.json({ 
      success: true, 
      data: ordersArray[purchaseOrderIndex],
      message: `Purchase order status updated to ${status}`,
      previousStatus: previousStatus
    });
  } catch (error) {
    console.error("‚ùå Purchase order status update error:", error);
    res.status(500).json({ 
      success: false,
      error: "Failed to update purchase order status",
      details: error.message
    });
  }
});

// Enhanced Analytics API
app.get("/api/analytics", async (req, res) => {
  try {
    const { shop, period = '30d' } = req.query;
    const tokens = readJSON(TOKENS_FILE);
    const token = tokens[shop]?.access_token;
    const inventory = readJSON(INVENTORY_FILE);
    const purchaseOrders = readJSON(PURCHASE_ORDERS_FILE);
    
    if (!token) return res.status(403).json({ error: "App not installed" });

    console.log(`üìä Generating enhanced analytics for: ${shop}`);

    // Simple analytics query
    const ordersQuery = `
      query {
        orders(first: 100, sortKey: CREATED_AT, reverse: true) {
          edges {
            node {
              createdAt
              totalPriceSet {
                shopMoney {
                  amount
                }
              }
              displayFinancialStatus
            }
          }
        }
      }
    `;

    const ordersData = await graphql(shop, token, ordersQuery);
    
    // Simple analytics calculation
    const orders = ordersData.data?.orders?.edges || [];
    const totalRevenue = orders.reduce((sum, order) => {
      return sum + parseFloat(order.node.totalPriceSet?.shopMoney?.amount || 0);
    }, 0);

    // Calculate revenue by status for charts
    const revenueByStatus = {
      paid: 0,
      pending: 0,
      refunded: 0
    };

    orders.forEach(order => {
      const status = order.node.displayFinancialStatus?.toLowerCase() || 'pending';
      const amount = parseFloat(order.node.totalPriceSet?.shopMoney?.amount || 0);
      if (revenueByStatus[status] !== undefined) {
        revenueByStatus[status] += amount;
      }
    });

    // Inventory analytics
    const totalProducts = Object.keys(inventory).length;
    const lowStockCount = Object.values(inventory).filter(item => 
      item.initialInventory <= (item.reorderPoint || 5)
    ).length;
    const outOfStockCount = Object.values(inventory).filter(item => 
      item.initialInventory === 0
    ).length;

    // Purchase order analytics
    const poStatusCount = {
      ordered: purchaseOrders.filter(po => po.status === 'ordered').length,
      received: purchaseOrders.filter(po => po.status === 'received').length,
      cancelled: purchaseOrders.filter(po => po.status === 'cancelled').length
    };

    const analytics = {
      summary: {
        totalRevenue: parseFloat(totalRevenue.toFixed(2)),
        totalOrders: orders.length,
        averageOrderValue: orders.length > 0 ? parseFloat((totalRevenue / orders.length).toFixed(2)) : 0,
        period
      },
      charts: {
        revenueByStatus,
        inventoryHealth: {
          healthy: totalProducts - lowStockCount - outOfStockCount,
          lowStock: lowStockCount,
          outOfStock: outOfStockCount
        },
        purchaseOrderStatus: poStatusCount
      },
      inventory: {
        totalProducts,
        lowStockCount,
        outOfStockCount,
        healthyCount: totalProducts - lowStockCount - outOfStockCount
      },
      purchaseOrders: {
        total: purchaseOrders.length,
        ...poStatusCount
      }
    };
    
    console.log(`‚úÖ Enhanced analytics generated: $${analytics.summary.totalRevenue} revenue from ${analytics.summary.totalOrders} orders`);
    res.json(analytics);
  } catch (error) {
    console.error("‚ùå Analytics API error:", error);
    res.status(500).json({ error: "Failed to fetch analytics" });
  }
});

// Low Stock Alerts - Updated to use initial inventory as actual inventory
app.get("/api/alerts/low-stock", (req, res) => {
  try {
    const { shop } = req.query;
    const tokens = readJSON(TOKENS_FILE);
    const token = tokens[shop]?.access_token;
    const inventory = readJSON(INVENTORY_FILE);
    
    if (!token) return res.status(403).json({ error: "App not installed" });

    const lowStockItems = Object.entries(inventory)
      .filter(([sku, item]) => {
        const currentInventory = item.initialInventory || 0;
        const reorderPoint = item.reorderPoint || 5;
        return currentInventory <= reorderPoint;
      })
      .map(([sku, item]) => ({ 
        sku, 
        ...item,
        alertLevel: item.initialInventory === 0 ? 'out-of-stock' : 'low-stock'
      }));

    console.log(`üö® Found ${lowStockItems.length} low stock items for ${shop}`);
    res.json({ alerts: lowStockItems });
  } catch (error) {
    console.error("‚ùå Low stock alerts error:", error);
    res.status(500).json({ error: "Failed to fetch low stock alerts" });
  }
});

// Enhanced Test Shop Connection Endpoint
app.get("/api/test-connection", async (req, res) => {
  try {
    const { shop } = req.query;
    
    if (!shop) {
      return res.status(400).json({ error: "Missing shop parameter" });
    }

    const tokens = readJSON(TOKENS_FILE);
    const token = tokens[shop]?.access_token;
    
    if (!token) {
      return res.status(403).json({ 
        error: "No access token",
        debug: {
          installedShops: Object.keys(tokens),
          hasTokenForThisShop: false,
          shop: shop
        }
      });
    }

    // Test multiple endpoints
    const shopQuery = `
      query {
        shop {
          name
          email
          id
        }
      }
    `;

    const ordersQuery = `
      query {
        orders(first: 1) {
          edges {
            node {
              id
              name
            }
          }
        }
      }
    `;

    const [shopResult, ordersResult] = await Promise.all([
      graphql(shop, token, shopQuery).catch(e => ({ error: e.message })),
      graphql(shop, token, ordersQuery).catch(e => ({ error: e.message }))
    ]);

    const response = {
      success: true,
      shop: shopResult.data?.shop || shopResult.error,
      orders: {
        count: ordersResult.data?.orders?.edges?.length || 0,
        data: ordersResult.data?.orders || ordersResult.error,
        hasError: !!ordersResult.error
      },
      connection: {
        shop: shop,
        hasToken: true,
        tokenLength: token.length,
        scopes: tokens[shop]?.scopes || 'unknown'
      }
    };

    console.log('üîó Enhanced connection test:', response);
    res.json(response);
  } catch (error) {
    console.error("‚ùå Connection test failed:", error);
    res.status(500).json({ 
      error: "Connection test failed", 
      details: error.message,
      debug: {
        shop: req.query.shop,
        hasToken: false
      }
    });
  }
});

// Reinstall endpoint to fix scope issues
app.get("/reinstall", (req, res) => {
  const { shop } = req.query;
  if (!shop) return res.status(400).json({ error: "Missing shop parameter" });

  // Delete existing token to force reinstall
  const tokens = readJSON(TOKENS_FILE);
  delete tokens[shop];
  saveJSON(TOKENS_FILE, tokens);

  console.log(`üîÑ Forcing reinstall for shop: ${shop}`);
  
  const redirectUri = `${HOST}/auth/callback`;
  const installUrl = `https://${shop}/admin/oauth/authorize?client_id=${SHOPIFY_API_KEY}&scope=${SCOPES}&redirect_uri=${encodeURIComponent(redirectUri)}`;
  
  res.redirect(installUrl);
});

// Debug endpoint to check tokens and basic info
app.get("/api/debug-info", (req, res) => {
  const tokens = readJSON(TOKENS_FILE);
  const { shop } = req.query;
  
  const response = {
    environment: NODE_ENV,
    installedShops: Object.keys(tokens),
    totalTokens: Object.keys(tokens).length,
    currentShop: shop,
    hasTokenForCurrentShop: shop ? !!tokens[shop]?.access_token : false,
    tokenInfo: shop ? {
      hasToken: !!tokens[shop]?.access_token,
      installedAt: tokens[shop]?.installed_at,
      scopes: tokens[shop]?.scopes || 'unknown'
    } : null,
    requiredScopes: SCOPES
  };

  console.log('üîß Debug Info:', response);
  res.json(response);
});

// Debug orders endpoint
app.get("/api/debug-orders", async (req, res) => {
  const { shop } = req.query;
  const tokens = readJSON(TOKENS_FILE);
  const token = tokens[shop]?.access_token;
  
  res.json({
    shop,
    hasToken: !!token,
    tokenLength: token?.length,
    installedShops: Object.keys(tokens),
    scopes: tokens[shop]?.scopes || 'unknown'
  });
});

// Debug endpoint for order status
app.get("/api/debug-order-status", (req, res) => {
  try {
    const { orderId, shop } = req.query;
    
    const orderStatusData = readJSON(ORDERSTATUS_FILE);
    const tokens = readJSON(TOKENS_FILE);
    
    const response = {
      orderId,
      shop,
      hasToken: !!tokens[shop]?.access_token,
      installedShops: Object.keys(tokens),
      orderStatus: orderStatusData[orderId] || 'Not found',
      allOrderStatuses: Object.keys(orderStatusData)
    };
    
    console.log('üîß Order Status Debug:', response);
    res.json(response);
  } catch (error) {
    console.error('‚ùå Order status debug error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Debug endpoint to check specific product inventory
app.get("/api/debug-inventory", (req, res) => {
  try {
    const { sku, shop } = req.query;
    const inventoryData = readJSON(INVENTORY_FILE);
    const tokens = readJSON(TOKENS_FILE);
    
    const response = {
      sku,
      shop,
      inventoryData: inventoryData[sku] || 'Not found',
      allInventorySKUs: Object.keys(inventoryData),
      hasToken: !!tokens[shop]?.access_token
    };
    
    console.log('üîß Inventory Debug:', response);
    res.json(response);
  } catch (error) {
    console.error('‚ùå Inventory debug error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Debug endpoint for purchase order routes
app.get("/api/debug-purchase-order-routes", (req, res) => {
  const purchaseOrders = readJSON(PURCHASE_ORDERS_FILE);
  let ordersArray = [];
  
  if (Array.isArray(purchaseOrders)) {
    ordersArray = purchaseOrders;
  } else if (typeof purchaseOrders === 'object' && purchaseOrders !== null) {
    ordersArray = Object.values(purchaseOrders);
  }
  
  res.json({
    routes: {
      "POST /api/purchase-orders/:id/status": "Update purchase order status",
      "GET /api/purchase-orders": "Get all purchase orders",
      "POST /api/purchase-orders/create": "Create manual purchase order"
    },
    purchaseOrders: {
      count: ordersArray.length,
      ids: ordersArray.map(po => po.id),
      sample: ordersArray[0] || 'No purchase orders'
    },
    filePath: PURCHASE_ORDERS_FILE,
    fileExists: fs.existsSync(PURCHASE_ORDERS_FILE)
  });
});

// Order status system health check
app.get("/api/order-status-health", (req, res) => {
  try {
    const orderStatusData = readJSON(ORDERSTATUS_FILE);
    const purchaseOrders = readJSON(PURCHASE_ORDERS_FILE);
    
    res.json({
      status: 'healthy',
      orderStatusCount: Object.keys(orderStatusData).length,
      purchaseOrderCount: Array.isArray(purchaseOrders) ? purchaseOrders.length : 0,
      filePaths: {
        orderStatus: ORDERSTATUS_FILE,
        purchaseOrders: PURCHASE_ORDERS_FILE,
        tokens: TOKENS_FILE
      },
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    res.status(500).json({ 
      status: 'error', 
      error: error.message 
    });
  }
});

// Enhanced Inventory endpoints with better validation
app.get("/api/inventory", (req, res) => {
  try {
    const inventory = readJSON(INVENTORY_FILE);
    const lowStockItems = Object.entries(inventory)
      .filter(([sku, item]) => item.initialInventory <= (item.reorderPoint || 5))
      .reduce((acc, [sku, item]) => {
        acc[sku] = item;
        return acc;
      }, {});

    console.log(`üì¶ Serving inventory data:`, {
      totalItems: Object.keys(inventory).length,
      lowStockItems: Object.keys(lowStockItems).length,
      zeroInventory: Object.entries(inventory).filter(([_, item]) => item.initialInventory === 0).length
    });
    
    res.json(inventory);
  } catch (error) {
    console.error("‚ùå Inventory read error:", error);
    res.status(500).json({ error: "Failed to read inventory" });
  }
});

// FIXED: Enhanced inventory save endpoint with strict validation - NO NEGATIVE VALUES
app.post("/api/inventory", (req, res) => {
  try {
    const { sku, initialInventory, reorderPoint = 5 } = req.body;
    
    console.log('üì¶ Inventory save request:', { sku, initialInventory, reorderPoint });
    
    if (!sku || initialInventory == null) {
      return res.status(400).json({ 
        success: false,
        error: "Missing SKU or initial inventory" 
      });
    }

    // Validate inventory value
    const inventoryValue = parseInt(initialInventory);
    if (isNaN(inventoryValue)) {
      return res.status(400).json({
        success: false,
        error: "Invalid inventory value - must be a number"
      });
    }

    // FIXED: STRICTLY PREVENT negative inventory values
    if (inventoryValue < 0) {
      return res.status(400).json({
        success: false,
        error: "Inventory value cannot be negative. Please enter 0 or higher."
      });
    }

    const data = readJSON(INVENTORY_FILE);
    data[sku] = { 
      initialInventory: inventoryValue,
      reorderPoint: parseInt(reorderPoint),
      lastUpdated: new Date().toISOString()
    };
    
    const saveSuccess = saveJSON(INVENTORY_FILE, data);
    if (!saveSuccess) {
      throw new Error('Failed to save inventory data to file');
    }
    
    console.log(`‚úÖ Saved inventory for SKU: ${sku} = ${inventoryValue}`);
    res.json({ 
      success: true, 
      data: data[sku],
      message: `Inventory set to ${inventoryValue} for SKU: ${sku}`
    });
  } catch (error) {
    console.error("‚ùå Inventory save error:", error);
    res.status(500).json({ 
      success: false,
      error: "Failed to save inventory",
      details: error.message
    });
  }
});

// New endpoint to get low stock report
app.get("/api/inventory/low-stock-report", (req, res) => {
  try {
    const inventory = readJSON(INVENTORY_FILE);
    
    const report = {
      totalProducts: Object.keys(inventory).length,
      lowStock: [],
      outOfStock: [],
      healthyStock: []
    };

    Object.entries(inventory).forEach(([sku, item]) => {
      const stockItem = { sku, ...item };
      
      if (item.initialInventory === 0) {
        report.outOfStock.push(stockItem);
      } else if (item.initialInventory <= (item.reorderPoint || 5)) {
        report.lowStock.push(stockItem);
      } else {
        report.healthyStock.push(stockItem);
      }
    });

    console.log(`üìä Inventory Report:`, {
      total: report.totalProducts,
      outOfStock: report.outOfStock.length,
      low: report.lowStock.length,
      healthy: report.healthyStock.length
    });

    res.json(report);
  } catch (error) {
    console.error("‚ùå Inventory report error:", error);
    res.status(500).json({ error: "Failed to generate inventory report" });
  }
});

// Health check
app.get("/health", (req, res) => {
  res.json({ 
    status: "OK", 
    timestamp: new Date().toISOString(),
    environment: NODE_ENV,
    requiredScopes: SCOPES
  });
});

// API health check endpoint
app.get("/api/health-check", (req, res) => {
  res.json({ 
    status: "API Healthy", 
    timestamp: new Date().toISOString(),
    environment: NODE_ENV,
    endpoints: [
      '/api/products',
      '/api/orders', 
      '/api/purchase-orders',
      '/api/analytics',
      '/api/inventory'
    ]
  });
});

// Ensure API routes don't get served as static files
app.use('/api/', (req, res, next) => {
  next();
});

// Enhanced error handling middleware for API routes
app.use('/api/', (error, req, res, next) => {
  console.error('üí• API Error:', error);
  res.status(500).json({ 
    error: 'Internal server error',
    message: error.message,
    ...(NODE_ENV === 'development' && { stack: error.stack })
  });
});

// 404 handler for API routes
app.use('/api/', (req, res) => {
  res.status(404).json({ error: 'API route not found' });
});

// Serve frontend - THIS SHOULD BE LAST
const frontendPath = path.join(__dirname, "../frontend/dist");
if (fs.existsSync(frontendPath)) {
  app.use(express.static(frontendPath));
  
  // Update the catch-all route to exclude API routes
  app.get("*", (req, res) => {
    // Don't serve API routes as HTML
    if (req.path.startsWith('/api/')) {
      return res.status(404).json({ error: 'API route not found' });
    }
    res.sendFile(path.join(frontendPath, "index.html"));
  });
} else {
  console.log('‚ö†Ô∏è Frontend build not found, serving API only');
  app.get("/", (req, res) => {
    res.json({ 
      message: "Shopify Inventory App API", 
      endpoints: [
        "/health",
        "/api/products?shop=your-store",
        "/api/orders?shop=your-store",
        "/api/purchase-orders",
        "/api/test-connection?shop=your-store",
        "/reinstall?shop=your-store (to fix scope issues)"
      ],
      requiredScopes: SCOPES
    });
  });
}

// Error handling middleware
app.use((error, req, res, next) => {
  console.error('üí• Unhandled error:', error);
  res.status(500).json({ 
    error: 'Internal server error',
    ...(NODE_ENV === 'development' && { stack: error.stack })
  });
});

// 404 handler
app.use((req, res) => {
  res.status(404).json({ error: 'Route not found' });
});

app.listen(PORT, () => {
  console.log(`\nüöÄ Shopify Inventory App Running`);
  console.log(`üìç Port: ${PORT}`);
  console.log(`üåê Host: ${HOST}`);
  console.log(`üåç Environment: ${NODE_ENV}`);
  console.log(`üìã Required Scopes: ${SCOPES}`);
  console.log(`\nüìä Available Endpoints:`);
  console.log(`   ‚Ä¢ Health: ${HOST}/health`);
  console.log(`   ‚Ä¢ Products: ${HOST}/api/products?shop=your-store`);
  console.log(`   ‚Ä¢ Orders: ${HOST}/api/orders?shop=your-store`);
  console.log(`   ‚Ä¢ Purchase Orders: ${HOST}/api/purchase-orders`);
  console.log(`   ‚Ä¢ Test Connection: ${HOST}/api/test-connection?shop=your-store`);
  console.log(`   ‚Ä¢ Reinstall (fix scopes): ${HOST}/reinstall?shop=your-store`);
  console.log(`\n‚úÖ Ready to serve data!`);
});